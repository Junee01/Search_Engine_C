# 빅데이터 검색엔진

## 프로젝트 선정 이유

2학년 자료구조 수업 시간에 처음으로 경험한 팀 프로젝트 입니다. 동기 한명과 함께 작업을 했는데, 이 때는 버전 관리 개념도 알 지 못해서 함께 소스를 공유하면서, 고치고 또 고치면서 작업했던 기억이 납니다. 개발자가 되기로 결심하고 처음으로 열심히 공부한 언어가 C언어 입니다. 둘이 머리를 맞대고 어떻게 하면 더 빠르고 정확한 검색을 할 수 있을 까 고민했습니다. 그리고 해당 클래스에서 다른 팀과 큰 차이로 1등을 했던 검색엔진입니다. 단순히 언어의 문법만 공부하다가 자료구조를 접하면서 여러 방면으로 활용이 가능한 구조들이 있다는 것을 깨닫게 해준 프로젝트입니다.

## 미션 프로젝트 요약

- 시간적, 메모리 효율성을 모두 고려하여 구현하였습니다.
- 자료구조 수업에서 배운 내용을 기반으로 구현하였습니다. "This와 This는 다르다고 가정합니다.
- 검색 결가는 오름차순으로 정렬되어 있어야 하며 단어, 총 개수, 나타난 줄 번호 순으로 구성됩니다.
- 결과 화면은 txt 파일에 저장되며, 미리 정해준 양식대로 출력되어야만 합니다. (오차율 분석이 체점 기준)
- 단순 txt 파일이지만, 30MB ~ 50MB 정도의 대량의 텍스트 파일을 대상으로 합니다.
- 학생은 헤더파일(.h)만 작성하며, 기본적인 main.c 틀은 제공받습니다.
- 체점에 사용될 단어는 50~100개 정도의 단어이며, 비공개입니다.
- abc, acb, bac, bca, cab, cba 를 모두 다른 단어로 판별하도록 합니다. (헤시 사용하는 사람 주의)

## 프로젝트 풀이

- 단어별로 파싱

(의미있는 단어 단위로만 검색을 할 것이므로, 저장또한 필요없는 문자나 띄어쓰기를 없애서 저장)
미션에서 주어진 조건은 띄어쓰기 단위이므로, 띄어쓰기에 초점을 두어 알고리즘을 수행한다. 읽는 단위는 한줄이며, 소설책은 보통 256 음절을 기준으로 쓰여지므로, 충분한 공간을 두어 한 줄 단위로 읽어 현재 읽고 있는 줄이 몇 번 째 줄인지 채크한다.하지만, 다른 문자가 섞이거나 응용의 가능성을 생각하여 다른 문자가 조건으로 나올 경우에도 처리할 수 있도록 정형화하여 구현한다. (delimiter 에 필요한 특수문작나 처리를 넣으면 자동으로 분류 대상이 추가되도록 구현)

- 중복없이 저장, 효율적 검색

(해시를 사용하여 단어값들을 저장하고 추출하면, 이상적인 경우 매우 효율적, 그러므로 충돌을 최소화 하여 해시 테이블을 생성.)
해시 테이블의 충돌의 경우 chaining 기법을 이용하여 길이를 늘려가며 갯수를 파악. 테이블을 만들 때, 단어의 음절의 순서에 두어 구현. 단순 fodling 방식에서는 "abd", "cba" 의 해시 값이 같음. 이는 단어의 수가 많아질 경우 overflow 가 발생할 가능성이 있음. 그러므로 shift 연산을 통하여 글자 배치의 순서에 따라 다른 값을 가지도록 처리. hardware 적으로 shift 연산이 빠르다고 알려져 있으므로 적용하여 구현.

## 프로젝트 소감

검색엔진은 많은 학교와 클래스에서 연습용으로 자주 주어지는 미션입니다. 하지만, 자료구조를 처음으로 가르치시는 교수님께서 조금의 변화를 주어 처음 시도했던 미션이었습니다. 단순히 검색을 하여 가져오는 소스를 통하여 결과물을 도출한 대부분의 학생들은 몇 초 ~ 몇 분까지 검색 시간이 걸렸습니다. 하지만, 실제 저희는 0.5 초 이하로 결과가 나왔고, 1등을 했습니다. 중복없이 해시 테이블을 만들기 위해서 처음으로 영어로 된 사이트인 Stack overflow 를 참고했고, 소스를 배끼지 않고, 창작하여 만든 첫 작품이었습니다. 저는 문과로 컴퓨터 공학과에 입학해서 다른 학우들과 실력 차이가 많다고 생각해서 더욱 열심히 공부했습니다. 그리고 처음으로 다른 학생들보다 좋은 결과를 얻었던 경험을 했습니다. 덕분에 프로그래밍에 자신감을 준 프로젝트입니다.
